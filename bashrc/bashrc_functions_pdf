# PDF-related
# ===========

# Add a paper, 2-up
#  arg 1: reading file
# (arg 3-6: trim dimensions for pdfnup)
function addreading() {
	# TODO: if the target filename doesn't match schema format then generate auth16_paper-title.pdf with `read` input
	# crop the PDF and move the original to the originals directory (renamed to auth16_uncropped.pdf)
	pdftrim "$@"
	trim_ret_code=$?
	if [ $trim_ret_code -gt 0 ]; then return $trim_ret_code; fi
	# if directory(file)/originals doesn't exist then make it
	originals_dir="$(dirname $outputpdf)/originals/"
	if [ ! -d "$originals_dir" ]; then
		>&2 printf "Creating a new folder '$originals_dir' [enter to confirm] :"
		mkdir "$originals_dir"
	fi
	base_in=$(basename $inputpdf)
	base_out=$(basename $outputpdf)
	base_out_denup="$(basename $outputpdf -nup.pdf).pdf"
	if [ "$base_in" = "$base_out_denup" ]; then
		# in all likelihood [i.e. by design] this rename destination is just input filename BUT doesn't need be
		# in case you accidentally run pdfnup on an already-trimmed/2-upped file, don't overwrite originals:
		mv $inputpdf --backup=t "$originals_dir/"
		# do overwrite cropped versions (e.g. trying out different settings from the 
		mv $outputpdf $(dirname $outputpdf)/$base_out_denup
	else
		mv $inputpdf --backup=t "$originals_dir/" # the output file has already been renamed, move on
	fi
	return 0
}

# Extending idea: Recrop - match a cropped file to its originals/ copy and then recrop with given trim values
function recropreading() {
	re_pdf=$1
	re_pdf_dir=$(dirname $re_pdf)
	# if a file exists with the same name in the child originals/ folder
	re_pdf_original=$re_pdf_dir/originals/$(basename $re_pdf)
	if [ -z $re_pdf_original ]; then
		>&2 echo "No such original file (or the name has been changed)."
		return 6
	fi
	mv $re_pdf_original $re_pdf
	addreading "$@"
}

# Crop a paper with `pdfnup --trim 'l b r t' input.pdf`
#  arg 1: reading file
# (arg 2: optional output filename)
#  arg 3(-6): trim dimensions for pdfnup - a single number to be used for all dimensions or 4 separate
# Returns 0 exit code if successful, 1-5 if it fails at the numbered error points
function pdftrim() {
	# checking "$2 -eq $2" actually asks
	# if $2 is an integer (i.e. not the output filename) http://stackoverflow.com/a/808740/2668831
	explicit_outfile="1" # switch to make output filename explicit: 0 for false, 1 for true
	if [ $2 -eq $2 ] 2>/dev/null; then
		inputpdf=$1
		if [ $explicit_outfile -eq 1 ]; then
			outputpdf=$(basename "$inputpdf" '.pdf')"-nup.pdf"
		else outputpdf=''
		fi
	elif [ $3 -eq $3 ] 2>/dev/null; then
		inputpdf=$1
		outputpdf=$2
		shift # $1 is dropped, $2 becomes $1 but doesn't matter as stored it
		# now equivalent to test no. of dimension variables as it is when no outfile specified
	else
		>&2 echo 'Please provide trim dimensions (anti-c/w from left) with the filename(s).'
		return 1
	fi
	if [ -z $1 ]; then
		>&2 echo 'Please provide trim dimensions (anti-c/w from left) with the filename(s).'
		return 2
	fi
	if [ -z $2 ]; then
		>&2 echo 'No trim dimensions specified: "<- v -> ^" (anti-c/w from left).'
		return 3
	fi
	# if the array generated by bash parameter expansion of space-separated variable $2 has 4 values
	arg2_as_array=($2)
	if [ ${#arg2_as_array[@]} -eq 4 ] 2>/dev/null; then
		trim_dims=($2) # not double quoting is essential here
	elif [ $# -eq 5 ]; then
		trim_dims=($2 $3 $4 $5)
		if [ ${#trim_dims[@]} -ne 4 ] 2>/dev/null; then
			>&2 echo 'Wrong number of trim dimensions specified? Give them as "<- v -> ^" (anti-c/w from left).'
			return 4
		fi
	elif [ $2 -eq $2 ] 2>/dev/null && [ $# -eq 2 ]; then
		trim_dims=($2 $2 $2 $2)
	else
		>&2 echo 'Wrong number of trim dimensions specified: "<- v -> ^" (anti-c/w from left).'
		return 5
	fi
	trim_param="${trim_dims[0]} ${trim_dims[1]} ${trim_dims[2]} ${trim_dims[3]}"
	if [[ -z $outputpdf ]];
	then pdfnup --trim "$trim_param" $inputpdf
	else pdfnup --trim "$trim_param" $inputpdf -o $outputpdf
	fi
	return 0
}
